# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cluster.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import TYPE_CHECKING, Dict, List, Optional

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import client as _client__

if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class MemberInfoVNodeState(betterproto.Enum):
    Initializing = 0
    DiscoverLeader = 1
    Unknown = 2
    PreReplica = 3
    CatchingUp = 4
    Clone = 5
    Follower = 6
    PreLeader = 7
    Leader = 8
    Manager = 9
    ShuttingDown = 10
    Shutdown = 11
    ReadOnlyLeaderless = 12
    PreReadOnlyReplica = 13
    ReadOnlyReplica = 14
    ResigningLeader = 15


@dataclass(eq=False, repr=False)
class GossipRequest(betterproto.Message):
    info: "ClusterInfo" = betterproto.message_field(1)
    server: "EndPoint" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ViewChangeRequest(betterproto.Message):
    server_id: "_client__.Uuid" = betterproto.message_field(1)
    server_http: "EndPoint" = betterproto.message_field(2)
    attempted_view: int = betterproto.int32_field(3)


@dataclass(eq=False, repr=False)
class ViewChangeProofRequest(betterproto.Message):
    server_id: "_client__.Uuid" = betterproto.message_field(1)
    server_http: "EndPoint" = betterproto.message_field(2)
    installed_view: int = betterproto.int32_field(3)


@dataclass(eq=False, repr=False)
class PrepareRequest(betterproto.Message):
    server_id: "_client__.Uuid" = betterproto.message_field(1)
    server_http: "EndPoint" = betterproto.message_field(2)
    view: int = betterproto.int32_field(3)


@dataclass(eq=False, repr=False)
class PrepareOkRequest(betterproto.Message):
    view: int = betterproto.int32_field(1)
    server_id: "_client__.Uuid" = betterproto.message_field(2)
    server_http: "EndPoint" = betterproto.message_field(3)
    epoch_number: int = betterproto.int32_field(4)
    epoch_position: int = betterproto.int64_field(5)
    epoch_id: "_client__.Uuid" = betterproto.message_field(6)
    epoch_leader_instance_id: "_client__.Uuid" = betterproto.message_field(7)
    last_commit_position: int = betterproto.int64_field(8)
    writer_checkpoint: int = betterproto.int64_field(9)
    chaser_checkpoint: int = betterproto.int64_field(10)
    node_priority: int = betterproto.int32_field(11)
    cluster_info: "ClusterInfo" = betterproto.message_field(12)


@dataclass(eq=False, repr=False)
class ProposalRequest(betterproto.Message):
    server_id: "_client__.Uuid" = betterproto.message_field(1)
    server_http: "EndPoint" = betterproto.message_field(2)
    leader_id: "_client__.Uuid" = betterproto.message_field(3)
    leader_http: "EndPoint" = betterproto.message_field(4)
    view: int = betterproto.int32_field(5)
    epoch_number: int = betterproto.int32_field(6)
    epoch_position: int = betterproto.int64_field(7)
    epoch_id: "_client__.Uuid" = betterproto.message_field(8)
    epoch_leader_instance_id: "_client__.Uuid" = betterproto.message_field(9)
    last_commit_position: int = betterproto.int64_field(10)
    writer_checkpoint: int = betterproto.int64_field(11)
    chaser_checkpoint: int = betterproto.int64_field(12)
    node_priority: int = betterproto.int32_field(13)


@dataclass(eq=False, repr=False)
class AcceptRequest(betterproto.Message):
    server_id: "_client__.Uuid" = betterproto.message_field(1)
    server_http: "EndPoint" = betterproto.message_field(2)
    leader_id: "_client__.Uuid" = betterproto.message_field(3)
    leader_http: "EndPoint" = betterproto.message_field(4)
    view: int = betterproto.int32_field(5)


@dataclass(eq=False, repr=False)
class LeaderIsResigningRequest(betterproto.Message):
    leader_id: "_client__.Uuid" = betterproto.message_field(1)
    leader_http: "EndPoint" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class LeaderIsResigningOkRequest(betterproto.Message):
    leader_id: "_client__.Uuid" = betterproto.message_field(1)
    leader_http: "EndPoint" = betterproto.message_field(2)
    server_id: "_client__.Uuid" = betterproto.message_field(3)
    server_http: "EndPoint" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class ClusterInfo(betterproto.Message):
    members: List["MemberInfo"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EndPoint(betterproto.Message):
    address: str = betterproto.string_field(1)
    port: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class MemberInfo(betterproto.Message):
    instance_id: "_client__.Uuid" = betterproto.message_field(1)
    time_stamp: int = betterproto.int64_field(2)
    state: "MemberInfoVNodeState" = betterproto.enum_field(3)
    is_alive: bool = betterproto.bool_field(4)
    http_end_point: "EndPoint" = betterproto.message_field(5)
    internal_tcp: "EndPoint" = betterproto.message_field(6)
    external_tcp: "EndPoint" = betterproto.message_field(7)
    internal_tcp_uses_tls: bool = betterproto.bool_field(8)
    external_tcp_uses_tls: bool = betterproto.bool_field(9)
    last_commit_position: int = betterproto.int64_field(10)
    writer_checkpoint: int = betterproto.int64_field(11)
    chaser_checkpoint: int = betterproto.int64_field(12)
    epoch_position: int = betterproto.int64_field(13)
    epoch_number: int = betterproto.int32_field(14)
    epoch_id: "_client__.Uuid" = betterproto.message_field(15)
    node_priority: int = betterproto.int32_field(16)
    is_read_only_replica: bool = betterproto.bool_field(17)
    advertise_host_to_client_as: str = betterproto.string_field(18)
    advertise_http_port_to_client_as: int = betterproto.uint32_field(19)
    advertise_tcp_port_to_client_as: int = betterproto.uint32_field(20)
    es_version: str = betterproto.string_field(21)


@dataclass(eq=False, repr=False)
class ReplicaLogWrite(betterproto.Message):
    log_position: int = betterproto.int64_field(1)
    replica_id: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class ReplicatedTo(betterproto.Message):
    log_position: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class Epoch(betterproto.Message):
    epoch_position: int = betterproto.int64_field(1)
    epoch_number: int = betterproto.int32_field(2)
    epoch_id: bytes = betterproto.bytes_field(3)


@dataclass(eq=False, repr=False)
class SubscribeReplica(betterproto.Message):
    log_position: int = betterproto.int64_field(1)
    chunk_id: bytes = betterproto.bytes_field(2)
    last_epochs: List["Epoch"] = betterproto.message_field(3)
    ip: bytes = betterproto.bytes_field(4)
    port: int = betterproto.int32_field(5)
    leader_id: bytes = betterproto.bytes_field(6)
    subscription_id: bytes = betterproto.bytes_field(7)
    is_promotable: bool = betterproto.bool_field(8)
    version: int = betterproto.int32_field(9)


@dataclass(eq=False, repr=False)
class ReplicaSubscriptionRetry(betterproto.Message):
    leader_id: bytes = betterproto.bytes_field(1)
    subscription_id: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class ReplicaSubscribed(betterproto.Message):
    leader_id: bytes = betterproto.bytes_field(1)
    subscription_id: bytes = betterproto.bytes_field(2)
    subscription_position: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class ReplicaLogPositionAck(betterproto.Message):
    subscription_id: bytes = betterproto.bytes_field(1)
    replication_log_position: int = betterproto.int64_field(2)
    writer_log_position: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class CreateChunk(betterproto.Message):
    leader_id: bytes = betterproto.bytes_field(1)
    subscription_id: bytes = betterproto.bytes_field(2)
    chunk_header_bytes: bytes = betterproto.bytes_field(3)
    file_size: int = betterproto.int32_field(4)
    is_completed_chunk: bool = betterproto.bool_field(5)


@dataclass(eq=False, repr=False)
class RawChunkBulk(betterproto.Message):
    leader_id: bytes = betterproto.bytes_field(1)
    subscription_id: bytes = betterproto.bytes_field(2)
    chunk_start_number: int = betterproto.int32_field(3)
    chunk_end_number: int = betterproto.int32_field(4)
    raw_position: int = betterproto.int32_field(5)
    raw_bytes: bytes = betterproto.bytes_field(6)
    complete_chunk: bool = betterproto.bool_field(7)


@dataclass(eq=False, repr=False)
class DataChunkBulk(betterproto.Message):
    leader_id: bytes = betterproto.bytes_field(1)
    subscription_id: bytes = betterproto.bytes_field(2)
    chunk_start_number: int = betterproto.int32_field(3)
    chunk_end_number: int = betterproto.int32_field(4)
    subscription_position: int = betterproto.int64_field(5)
    data_bytes: bytes = betterproto.bytes_field(6)
    complete_chunk: bool = betterproto.bool_field(7)


@dataclass(eq=False, repr=False)
class FollowerAssignment(betterproto.Message):
    leader_id: bytes = betterproto.bytes_field(1)
    subscription_id: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class CloneAssignment(betterproto.Message):
    leader_id: bytes = betterproto.bytes_field(1)
    subscription_id: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class DropSubscription(betterproto.Message):
    leader_id: bytes = betterproto.bytes_field(1)
    subscription_id: bytes = betterproto.bytes_field(2)


class GossipStub(betterproto.ServiceStub):
    async def update(
        self,
        gossip_request: "GossipRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ClusterInfo":
        return await self._unary_unary(
            "/event_store.cluster.Gossip/Update",
            gossip_request,
            ClusterInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def read(
        self,
        client_empty: "_client__.Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ClusterInfo":
        return await self._unary_unary(
            "/event_store.cluster.Gossip/Read",
            client_empty,
            ClusterInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ElectionsStub(betterproto.ServiceStub):
    async def view_change(
        self,
        view_change_request: "ViewChangeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_client__.Empty":
        return await self._unary_unary(
            "/event_store.cluster.Elections/ViewChange",
            view_change_request,
            _client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def view_change_proof(
        self,
        view_change_proof_request: "ViewChangeProofRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_client__.Empty":
        return await self._unary_unary(
            "/event_store.cluster.Elections/ViewChangeProof",
            view_change_proof_request,
            _client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def prepare(
        self,
        prepare_request: "PrepareRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_client__.Empty":
        return await self._unary_unary(
            "/event_store.cluster.Elections/Prepare",
            prepare_request,
            _client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def prepare_ok(
        self,
        prepare_ok_request: "PrepareOkRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_client__.Empty":
        return await self._unary_unary(
            "/event_store.cluster.Elections/PrepareOk",
            prepare_ok_request,
            _client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def proposal(
        self,
        proposal_request: "ProposalRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_client__.Empty":
        return await self._unary_unary(
            "/event_store.cluster.Elections/Proposal",
            proposal_request,
            _client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def accept(
        self,
        accept_request: "AcceptRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_client__.Empty":
        return await self._unary_unary(
            "/event_store.cluster.Elections/Accept",
            accept_request,
            _client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def leader_is_resigning(
        self,
        leader_is_resigning_request: "LeaderIsResigningRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_client__.Empty":
        return await self._unary_unary(
            "/event_store.cluster.Elections/LeaderIsResigning",
            leader_is_resigning_request,
            _client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def leader_is_resigning_ok(
        self,
        leader_is_resigning_ok_request: "LeaderIsResigningOkRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_client__.Empty":
        return await self._unary_unary(
            "/event_store.cluster.Elections/LeaderIsResigningOk",
            leader_is_resigning_ok_request,
            _client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class GossipBase(ServiceBase):
    async def update(self, gossip_request: "GossipRequest") -> "ClusterInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def read(self, client_empty: "_client__.Empty") -> "ClusterInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_update(
        self, stream: "grpclib.server.Stream[GossipRequest, ClusterInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update(request)
        await stream.send_message(response)

    async def __rpc_read(
        self, stream: "grpclib.server.Stream[_client__.Empty, ClusterInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.read(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/event_store.cluster.Gossip/Update": grpclib.const.Handler(
                self.__rpc_update,
                grpclib.const.Cardinality.UNARY_UNARY,
                GossipRequest,
                ClusterInfo,
            ),
            "/event_store.cluster.Gossip/Read": grpclib.const.Handler(
                self.__rpc_read,
                grpclib.const.Cardinality.UNARY_UNARY,
                _client__.Empty,
                ClusterInfo,
            ),
        }


class ElectionsBase(ServiceBase):
    async def view_change(
        self, view_change_request: "ViewChangeRequest"
    ) -> "_client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def view_change_proof(
        self, view_change_proof_request: "ViewChangeProofRequest"
    ) -> "_client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def prepare(self, prepare_request: "PrepareRequest") -> "_client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def prepare_ok(
        self, prepare_ok_request: "PrepareOkRequest"
    ) -> "_client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def proposal(self, proposal_request: "ProposalRequest") -> "_client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def accept(self, accept_request: "AcceptRequest") -> "_client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def leader_is_resigning(
        self, leader_is_resigning_request: "LeaderIsResigningRequest"
    ) -> "_client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def leader_is_resigning_ok(
        self, leader_is_resigning_ok_request: "LeaderIsResigningOkRequest"
    ) -> "_client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_view_change(
        self, stream: "grpclib.server.Stream[ViewChangeRequest, _client__.Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.view_change(request)
        await stream.send_message(response)

    async def __rpc_view_change_proof(
        self, stream: "grpclib.server.Stream[ViewChangeProofRequest, _client__.Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.view_change_proof(request)
        await stream.send_message(response)

    async def __rpc_prepare(
        self, stream: "grpclib.server.Stream[PrepareRequest, _client__.Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.prepare(request)
        await stream.send_message(response)

    async def __rpc_prepare_ok(
        self, stream: "grpclib.server.Stream[PrepareOkRequest, _client__.Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.prepare_ok(request)
        await stream.send_message(response)

    async def __rpc_proposal(
        self, stream: "grpclib.server.Stream[ProposalRequest, _client__.Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.proposal(request)
        await stream.send_message(response)

    async def __rpc_accept(
        self, stream: "grpclib.server.Stream[AcceptRequest, _client__.Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.accept(request)
        await stream.send_message(response)

    async def __rpc_leader_is_resigning(
        self, stream: "grpclib.server.Stream[LeaderIsResigningRequest, _client__.Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.leader_is_resigning(request)
        await stream.send_message(response)

    async def __rpc_leader_is_resigning_ok(
        self,
        stream: "grpclib.server.Stream[LeaderIsResigningOkRequest, _client__.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.leader_is_resigning_ok(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/event_store.cluster.Elections/ViewChange": grpclib.const.Handler(
                self.__rpc_view_change,
                grpclib.const.Cardinality.UNARY_UNARY,
                ViewChangeRequest,
                _client__.Empty,
            ),
            "/event_store.cluster.Elections/ViewChangeProof": grpclib.const.Handler(
                self.__rpc_view_change_proof,
                grpclib.const.Cardinality.UNARY_UNARY,
                ViewChangeProofRequest,
                _client__.Empty,
            ),
            "/event_store.cluster.Elections/Prepare": grpclib.const.Handler(
                self.__rpc_prepare,
                grpclib.const.Cardinality.UNARY_UNARY,
                PrepareRequest,
                _client__.Empty,
            ),
            "/event_store.cluster.Elections/PrepareOk": grpclib.const.Handler(
                self.__rpc_prepare_ok,
                grpclib.const.Cardinality.UNARY_UNARY,
                PrepareOkRequest,
                _client__.Empty,
            ),
            "/event_store.cluster.Elections/Proposal": grpclib.const.Handler(
                self.__rpc_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                ProposalRequest,
                _client__.Empty,
            ),
            "/event_store.cluster.Elections/Accept": grpclib.const.Handler(
                self.__rpc_accept,
                grpclib.const.Cardinality.UNARY_UNARY,
                AcceptRequest,
                _client__.Empty,
            ),
            "/event_store.cluster.Elections/LeaderIsResigning": grpclib.const.Handler(
                self.__rpc_leader_is_resigning,
                grpclib.const.Cardinality.UNARY_UNARY,
                LeaderIsResigningRequest,
                _client__.Empty,
            ),
            "/event_store.cluster.Elections/LeaderIsResigningOk": grpclib.const.Handler(
                self.__rpc_leader_is_resigning_ok,
                grpclib.const.Cardinality.UNARY_UNARY,
                LeaderIsResigningOkRequest,
                _client__.Empty,
            ),
        }
