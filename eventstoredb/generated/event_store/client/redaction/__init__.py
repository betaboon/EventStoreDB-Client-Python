# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: redaction.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ... import client as __client__

if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class GetEventPositionReq(betterproto.Message):
    stream_identifier: "__client__.StreamIdentifier" = betterproto.message_field(1)
    stream_revision: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class GetEventPositionResp(betterproto.Message):
    event_positions: List["EventPosition"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EventPosition(betterproto.Message):
    log_position: int = betterproto.uint64_field(1)
    chunk_info: "ChunkInfo" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ChunkInfo(betterproto.Message):
    file_name: str = betterproto.string_field(1)
    version: int = betterproto.uint32_field(2)
    is_complete: bool = betterproto.bool_field(3)
    event_offset: int = betterproto.uint32_field(4)


@dataclass(eq=False, repr=False)
class SwitchChunkReq(betterproto.Message):
    target_chunk_file: str = betterproto.string_field(1)
    new_chunk_file: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class SwitchChunkResp(betterproto.Message):
    pass


class RedactionStub(betterproto.ServiceStub):
    async def get_event_positions(
        self,
        get_event_position_req_iterator: Union[
            AsyncIterable["GetEventPositionReq"], Iterable["GetEventPositionReq"]
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["GetEventPositionResp"]:
        async for response in self._stream_stream(
            "/event_store.client.redaction.Redaction/GetEventPositions",
            get_event_position_req_iterator,
            GetEventPositionReq,
            GetEventPositionResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def switch_chunks(
        self,
        switch_chunk_req_iterator: Union[
            AsyncIterable["SwitchChunkReq"], Iterable["SwitchChunkReq"]
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["SwitchChunkResp"]:
        async for response in self._stream_stream(
            "/event_store.client.redaction.Redaction/SwitchChunks",
            switch_chunk_req_iterator,
            SwitchChunkReq,
            SwitchChunkResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class RedactionBase(ServiceBase):
    async def get_event_positions(
        self, get_event_position_req_iterator: AsyncIterator["GetEventPositionReq"]
    ) -> AsyncIterator["GetEventPositionResp"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def switch_chunks(
        self, switch_chunk_req_iterator: AsyncIterator["SwitchChunkReq"]
    ) -> AsyncIterator["SwitchChunkResp"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_event_positions(
        self, stream: "grpclib.server.Stream[GetEventPositionReq, GetEventPositionResp]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.get_event_positions,
            stream,
            request,
        )

    async def __rpc_switch_chunks(
        self, stream: "grpclib.server.Stream[SwitchChunkReq, SwitchChunkResp]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.switch_chunks,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/event_store.client.redaction.Redaction/GetEventPositions": grpclib.const.Handler(
                self.__rpc_get_event_positions,
                grpclib.const.Cardinality.STREAM_STREAM,
                GetEventPositionReq,
                GetEventPositionResp,
            ),
            "/event_store.client.redaction.Redaction/SwitchChunks": grpclib.const.Handler(
                self.__rpc_switch_chunks,
                grpclib.const.Cardinality.STREAM_STREAM,
                SwitchChunkReq,
                SwitchChunkResp,
            ),
        }
