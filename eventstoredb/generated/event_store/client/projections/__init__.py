# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: projections.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import TYPE_CHECKING, AsyncIterator, Dict, Optional

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ... import client as __client__

if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class CreateReq(betterproto.Message):
    options: "CreateReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CreateReqOptions(betterproto.Message):
    one_time: "__client__.Empty" = betterproto.message_field(1, group="mode")
    transient: "CreateReqOptionsTransient" = betterproto.message_field(2, group="mode")
    continuous: "CreateReqOptionsContinuous" = betterproto.message_field(
        3, group="mode"
    )
    query: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class CreateReqOptionsTransient(betterproto.Message):
    name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class CreateReqOptionsContinuous(betterproto.Message):
    name: str = betterproto.string_field(1)
    emit_enabled: bool = betterproto.bool_field(2)
    track_emitted_streams: bool = betterproto.bool_field(3)


@dataclass(eq=False, repr=False)
class CreateResp(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class UpdateReq(betterproto.Message):
    options: "UpdateReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateReqOptions(betterproto.Message):
    name: str = betterproto.string_field(1)
    query: str = betterproto.string_field(2)
    emit_enabled: bool = betterproto.bool_field(3, group="emit_option")
    no_emit_options: "__client__.Empty" = betterproto.message_field(
        4, group="emit_option"
    )


@dataclass(eq=False, repr=False)
class UpdateResp(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeleteReq(betterproto.Message):
    options: "DeleteReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DeleteReqOptions(betterproto.Message):
    name: str = betterproto.string_field(1)
    delete_emitted_streams: bool = betterproto.bool_field(2)
    delete_state_stream: bool = betterproto.bool_field(3)
    delete_checkpoint_stream: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class DeleteResp(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class StatisticsReq(betterproto.Message):
    options: "StatisticsReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StatisticsReqOptions(betterproto.Message):
    name: str = betterproto.string_field(1, group="mode")
    all: "__client__.Empty" = betterproto.message_field(2, group="mode")
    transient: "__client__.Empty" = betterproto.message_field(3, group="mode")
    continuous: "__client__.Empty" = betterproto.message_field(4, group="mode")
    one_time: "__client__.Empty" = betterproto.message_field(5, group="mode")


@dataclass(eq=False, repr=False)
class StatisticsResp(betterproto.Message):
    details: "StatisticsRespDetails" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StatisticsRespDetails(betterproto.Message):
    core_processing_time: int = betterproto.int64_field(1)
    version: int = betterproto.int64_field(2)
    epoch: int = betterproto.int64_field(3)
    effective_name: str = betterproto.string_field(4)
    writes_in_progress: int = betterproto.int32_field(5)
    reads_in_progress: int = betterproto.int32_field(6)
    partitions_cached: int = betterproto.int32_field(7)
    status: str = betterproto.string_field(8)
    state_reason: str = betterproto.string_field(9)
    name: str = betterproto.string_field(10)
    mode: str = betterproto.string_field(11)
    position: str = betterproto.string_field(12)
    progress: float = betterproto.float_field(13)
    last_checkpoint: str = betterproto.string_field(14)
    events_processed_after_restart: int = betterproto.int64_field(15)
    checkpoint_status: str = betterproto.string_field(16)
    buffered_events: int = betterproto.int64_field(17)
    write_pending_events_before_checkpoint: int = betterproto.int32_field(18)
    write_pending_events_after_checkpoint: int = betterproto.int32_field(19)


@dataclass(eq=False, repr=False)
class StateReq(betterproto.Message):
    options: "StateReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StateReqOptions(betterproto.Message):
    name: str = betterproto.string_field(1)
    partition: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class StateResp(betterproto.Message):
    state: "betterproto_lib_google_protobuf.Value" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ResultReq(betterproto.Message):
    options: "ResultReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ResultReqOptions(betterproto.Message):
    name: str = betterproto.string_field(1)
    partition: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ResultResp(betterproto.Message):
    result: "betterproto_lib_google_protobuf.Value" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ResetReq(betterproto.Message):
    options: "ResetReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ResetReqOptions(betterproto.Message):
    name: str = betterproto.string_field(1)
    write_checkpoint: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class ResetResp(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class EnableReq(betterproto.Message):
    options: "EnableReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EnableReqOptions(betterproto.Message):
    name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EnableResp(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DisableReq(betterproto.Message):
    options: "DisableReqOptions" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DisableReqOptions(betterproto.Message):
    name: str = betterproto.string_field(1)
    write_checkpoint: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class DisableResp(betterproto.Message):
    pass


class ProjectionsStub(betterproto.ServiceStub):
    async def create(
        self,
        create_req: "CreateReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "CreateResp":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/Create",
            create_req,
            CreateResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update(
        self,
        update_req: "UpdateReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "UpdateResp":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/Update",
            update_req,
            UpdateResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        delete_req: "DeleteReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DeleteResp":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/Delete",
            delete_req,
            DeleteResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def statistics(
        self,
        statistics_req: "StatisticsReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["StatisticsResp"]:
        async for response in self._unary_stream(
            "/event_store.client.projections.Projections/Statistics",
            statistics_req,
            StatisticsResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def disable(
        self,
        disable_req: "DisableReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DisableResp":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/Disable",
            disable_req,
            DisableResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def enable(
        self,
        enable_req: "EnableReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "EnableResp":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/Enable",
            enable_req,
            EnableResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def reset(
        self,
        reset_req: "ResetReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ResetResp":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/Reset",
            reset_req,
            ResetResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def state(
        self,
        state_req: "StateReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "StateResp":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/State",
            state_req,
            StateResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def result(
        self,
        result_req: "ResultReq",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ResultResp":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/Result",
            result_req,
            ResultResp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def restart_subsystem(
        self,
        client_empty: "__client__.Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "__client__.Empty":
        return await self._unary_unary(
            "/event_store.client.projections.Projections/RestartSubsystem",
            client_empty,
            __client__.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ProjectionsBase(ServiceBase):
    async def create(self, create_req: "CreateReq") -> "CreateResp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update(self, update_req: "UpdateReq") -> "UpdateResp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(self, delete_req: "DeleteReq") -> "DeleteResp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def statistics(
        self, statistics_req: "StatisticsReq"
    ) -> AsyncIterator["StatisticsResp"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def disable(self, disable_req: "DisableReq") -> "DisableResp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def enable(self, enable_req: "EnableReq") -> "EnableResp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def reset(self, reset_req: "ResetReq") -> "ResetResp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def state(self, state_req: "StateReq") -> "StateResp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def result(self, result_req: "ResultReq") -> "ResultResp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def restart_subsystem(
        self, client_empty: "__client__.Empty"
    ) -> "__client__.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create(
        self, stream: "grpclib.server.Stream[CreateReq, CreateResp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create(request)
        await stream.send_message(response)

    async def __rpc_update(
        self, stream: "grpclib.server.Stream[UpdateReq, UpdateResp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self, stream: "grpclib.server.Stream[DeleteReq, DeleteResp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_statistics(
        self, stream: "grpclib.server.Stream[StatisticsReq, StatisticsResp]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.statistics,
            stream,
            request,
        )

    async def __rpc_disable(
        self, stream: "grpclib.server.Stream[DisableReq, DisableResp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.disable(request)
        await stream.send_message(response)

    async def __rpc_enable(
        self, stream: "grpclib.server.Stream[EnableReq, EnableResp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.enable(request)
        await stream.send_message(response)

    async def __rpc_reset(
        self, stream: "grpclib.server.Stream[ResetReq, ResetResp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.reset(request)
        await stream.send_message(response)

    async def __rpc_state(
        self, stream: "grpclib.server.Stream[StateReq, StateResp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.state(request)
        await stream.send_message(response)

    async def __rpc_result(
        self, stream: "grpclib.server.Stream[ResultReq, ResultResp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.result(request)
        await stream.send_message(response)

    async def __rpc_restart_subsystem(
        self, stream: "grpclib.server.Stream[__client__.Empty, __client__.Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.restart_subsystem(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/event_store.client.projections.Projections/Create": grpclib.const.Handler(
                self.__rpc_create,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateReq,
                CreateResp,
            ),
            "/event_store.client.projections.Projections/Update": grpclib.const.Handler(
                self.__rpc_update,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateReq,
                UpdateResp,
            ),
            "/event_store.client.projections.Projections/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteReq,
                DeleteResp,
            ),
            "/event_store.client.projections.Projections/Statistics": grpclib.const.Handler(
                self.__rpc_statistics,
                grpclib.const.Cardinality.UNARY_STREAM,
                StatisticsReq,
                StatisticsResp,
            ),
            "/event_store.client.projections.Projections/Disable": grpclib.const.Handler(
                self.__rpc_disable,
                grpclib.const.Cardinality.UNARY_UNARY,
                DisableReq,
                DisableResp,
            ),
            "/event_store.client.projections.Projections/Enable": grpclib.const.Handler(
                self.__rpc_enable,
                grpclib.const.Cardinality.UNARY_UNARY,
                EnableReq,
                EnableResp,
            ),
            "/event_store.client.projections.Projections/Reset": grpclib.const.Handler(
                self.__rpc_reset,
                grpclib.const.Cardinality.UNARY_UNARY,
                ResetReq,
                ResetResp,
            ),
            "/event_store.client.projections.Projections/State": grpclib.const.Handler(
                self.__rpc_state,
                grpclib.const.Cardinality.UNARY_UNARY,
                StateReq,
                StateResp,
            ),
            "/event_store.client.projections.Projections/Result": grpclib.const.Handler(
                self.__rpc_result,
                grpclib.const.Cardinality.UNARY_UNARY,
                ResultReq,
                ResultResp,
            ),
            "/event_store.client.projections.Projections/RestartSubsystem": grpclib.const.Handler(
                self.__rpc_restart_subsystem,
                grpclib.const.Cardinality.UNARY_UNARY,
                __client__.Empty,
                __client__.Empty,
            ),
        }
